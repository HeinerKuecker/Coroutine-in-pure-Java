package de.heinerkuecker.coroutine.arg;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import de.heinerkuecker.coroutine.CoroCheckable;
import de.heinerkuecker.coroutine.CoroutineOrProcedureOrComplexstep;
import de.heinerkuecker.coroutine.exprs.CoroExpression;
import de.heinerkuecker.coroutine.exprs.GetProcedureArgument;
import de.heinerkuecker.coroutine.exprs.Value;

/**
 * Argument for procedure or
 * the entire coroutine.
 *
 * @param <T> argument/parameter type
 * @author Heiner K&uuml;cker
 */
public class Argument<T>
implements CoroCheckable
{
    public final String name;

    public final CoroExpression<T> expression;

    /**
     * Constructor.
     *
     * @param name
     * @param expression
     */
    public Argument(
            final String name ,
            final CoroExpression<T> expression )
    {
        this.name = Objects.requireNonNull( name );
        this.expression = Objects.requireNonNull( expression );
    }

    /**
     * Convenience Constructor.
     *
     * @param name
     * @param expression
     */
    public Argument(
            final String name ,
            final T value )
    {
        this.name = Objects.requireNonNull( name );

        this.expression =
                new Value<T>(
                        (Class<? extends T>) value.getClass() ,
                        value );
    }

    public T getValue(
            final CoroutineOrProcedureOrComplexstep<?, ?> parent )
    {
        @SuppressWarnings("unchecked")
        final Class<T> parameterType = (Class<T>) parent.procedureParameterTypes().get( name );

        return
                parameterType.cast(
                        this.expression.evaluate( parent ) );
    }

    @Override
    public List<GetProcedureArgument<?>> getProcedureArgumentGetsNotInProcedure()
    {
        return this.expression.getProcedureArgumentGetsNotInProcedure();
    }

    @Override
    public void checkUseVariables(
            final HashSet<String> alreadyCheckedProcedureNames ,
            final CoroutineOrProcedureOrComplexstep<?, ?> parent ,
            final Map<String, Class<?>> globalVariableTypes ,
            final Map<String, Class<?>> localVariableTypes )
    {
        this.expression.checkUseVariables(
                alreadyCheckedProcedureNames ,
                parent ,
                globalVariableTypes, localVariableTypes );
    }

    @Override
    public void checkUseArguments(
            final HashSet<String> alreadyCheckedProcedureNames ,
            final CoroutineOrProcedureOrComplexstep<?, ?> parent )
    {
        final Class<?> parameterType = parent.procedureParameterTypes().get( name );

        if ( parameterType == null )
        {
            throw new ArgumentNotDeclaredException( this );
        }

        final Class<? extends T>[] typeArr = this.expression.type();

        for ( final Class<? extends T> type : typeArr )
        {
            if ( ! parameterType.isAssignableFrom( type ) )
            {
                throw new WrongArgumentClassException(
                        //wrongExpression
                        this.expression ,
                        //wrongClass
                        type ,
                        //expectedClass
                        parameterType );
            }
        }

        this.expression.checkUseArguments(
                alreadyCheckedProcedureNames ,
                parent );
    }

    /**
     * @see Object#toString()
     */
    @Override
    public String toString()
    {
        return this.getClass().getSimpleName() + "[name=" + this.name + ", expression=" + this.expression + "]";
    }

    /**
     * Exception
     */
    public static class ArgumentNotDeclaredException
    extends RuntimeException
    {
        /**
         * Generated by Eclipse.
         */
        private static final long serialVersionUID = -2823336930271744702L;

        /**
         * Constructor.
         *
         * @param stepOrExpression step or expression with access to not declared global variable
         */
        //public <T extends HasCreationStackTraceElement & HasVariableName> ArgumentNotDeclaredException(
        //        final T stepOrExpression )
        public ArgumentNotDeclaredException(
                final Argument<?> argument )
        {
            super(
                    "argument not declared: " +
                    argument );
        }

    }

    /**
     * Exception
     */
    public static class WrongArgumentClassException
    extends RuntimeException
    {
        /**
         * Generated by Eclipse.
         */

        /**
         * Constructor.
         */
        public WrongArgumentClassException(
                //final HasVariableName wrongExpression ,
                final CoroExpression<?> wrongExpression ,
                final Class<?> wrongClass ,
                final Class<?> expectedClass )
        {
            super(
                    "wrong variable class for expression: " +
                    wrongExpression + ",\n" +
                    "expected class: " +
                    expectedClass + ", " +
                    "wrong class: " +
                    wrongClass );
        }
    }

}
